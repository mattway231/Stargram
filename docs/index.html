import requests
import config
from datetime import datetime

class FusionBrainAPI:
    def __init__(self):
        self.URL = 'https://api-key.fusionbrain.ai/'
        self.AUTH_HEADERS = {
            'X-Key': f'Key {config.FUSIONBRAIN_API_KEY}',
            'X-Secret': f'Secret {config.FUSIONBRAIN_API_KEY}',
        }
    
    def get_pipeline(self):
        response = requests.get(self.URL + 'key/api/v1/pipelines', headers=self.AUTH_HEADERS)
        data = response.json()
        return data[0]['id'] if data else None
    
    def generate(self, prompt, pipeline, style="DEFAULT", width=1024, height=1024, images=1, negative_prompt=""):
        params = {
            "type": "GENERATE",
            "style": style,
            "width": width,
            "height": height,
            "numImages": images,
            "negativePromptDecoder": negative_prompt,
            "generateParams": {
                "query": prompt
            }
        }
        
        data = {
            'pipeline_id': (None, pipeline),
            'params': (None, str(params).replace("'", '"'), 'application/json')
        }
        
        response = requests.post(
            self.URL + 'key/api/v1/pipeline/run', 
            headers=self.AUTH_HEADERS, 
            files=data
        )
        data = response.json()
        return data['uuid'] if 'uuid' in data else None
    
    def check_generation(self, request_id, attempts=10, delay=10):
        while attempts > 0:
            response = requests.get(
                self.URL + 'key/api/v1/pipeline/status/' + request_id, 
                headers=self.AUTH_HEADERS
            )
            data = response.json()
            if data['status'] == 'DONE':
                return data['result']['files'][0] if data['result']['files'] else None
            attempts -= 1
            time.sleep(delay)
        return None

class OpenRouterAPI:
    def __init__(self):
        self.URL = 'https://openrouter.ai/api/v1/chat/completions'
        self.HEADERS = {
            'Authorization': f'Bearer {config.OPENROUTER_API_KEY}',
            'HTTP-Referer': config.WEBAPP_URL,
            'X-Title': 'Stargram'
        }
    
    def chat_completion(self, messages, model="deepseek/deepseek-v3-base:free", max_tokens=2000):
        payload = {
            "model": model,
            "messages": messages,
            "max_tokens": max_tokens
        }
        
        response = requests.post(self.URL, headers=self.HEADERS, json=payload)
        data = response.json()
        
        if 'choices' in data and data['choices']:
            return data['choices'][0]['message']['content']
        return None

class CozeAPI:
    def __init__(self):
        self.URL = 'https://api.coze.com/v3/chat'
        self.HEADERS = {
            'Authorization': f'Bearer {config.COZE_API_KEY}',
            'Content-Type': 'application/json'
        }
        self.BOT_ID = config.COZE_AGENT_ID
    
    def check_complaint(self, user_id, message_text):
        payload = {
            "bot_id": self.BOT_ID,
            "user_id": str(user_id),
            "message": {
                "content": message_text,
                "type": "text"
            }
        }
        
        response = requests.post(self.URL, headers=self.HEADERS, json=payload)
        data = response.json()
        
        if 'output' in data and 'text' in data['output']:
            return "approve" if "approve" in data['output']['text'].lower() else "reject"
        return "reject"

class GeoAPI:
    @staticmethod
    def get_address(lat, lon):
        url = f"https://nominatim.openstreetmap.org/reverse?format=json&lat={lat}&lon={lon}"
        response = requests.get(url)
        data = response.json()
        return data.get('display_name', 'Неизвестный адрес')
    
    @staticmethod
    def generate_points(lat, lon, count=5, radius=5000):
        # Generate random points in parks near user
        points = []
        for _ in range(count):
            # Simple random point generation (in real app use OSM data)
            new_lat = lat + (random.uniform(-0.1, 0.1))
            new_lon = lon + (random.uniform(-0.1, 0.1))
            address = GeoAPI.get_address(new_lat, new_lon)
            value = random.randint(10000, 25000) if random.random() > 0.5 else random.randint(20000, 35000)
            points.append((new_lat, new_lon, address, value))
        return points

class PaymentSystem:
    @staticmethod
    def create_invoice(user_id, amount, currency, description):
        # In real app integrate with payment provider
        return f"{config.WEBAPP_URL}/payment/{user_id}/{uuid.uuid4()}"
    
    @staticmethod
    def check_payment(invoice_id):
        # In real app check payment status
        return True
